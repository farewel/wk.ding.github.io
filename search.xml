<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[神经网络基础]]></title>
    <url>%2FneuralNetBasic%2F</url>
    <content type="text"><![CDATA[一、神经元模型 神经元是神经网络中最基本的机构，神经元的两种状态：兴奋和抑制。大多数时候是处于抑制状态下，当收到刺激，导致点位超过阔值，神经元会被激活，处于“兴奋”状态，进而向其他神经元传播化学物质（信息） 根据生物神经元构造了人工神经元（Artificial Neural Networks,简称ANN），也是常用的“M-P神经元模型”。 神经元的输出$$ y=f(\sum_{i=0}^n w_ix_i-\theta)$$其中$\theta$为阔值，函数为激活函数。其中函数可以用阶跃函数表示，由于阶跃函数不连续，不可导，所以常用sigmoid 函数来表函数。 sigmoid函数的表达式和分布图如下： $$f(x) = \frac{1}{1+e^-x}$$ ###二、神经网络部分清单 1.前馈神经网络（FFNN/FF）前馈神经感知网络与感知机（FF or FFNN:Feed forward neural networks ad P:perceptrons），信息从前往后流动（分别对应输入和输出） 一般在描述神经网络时，都是从层说起，即相互平行的输入层、隐含层或者输出层神经结构。单独的神经系统层内部，神经元之间互不相连；而一般相邻的两个神经细胞则是全连接（一层的每个神经元和另一层的每个神经元相连）。一个最简单却最实用性的神经网络由两个输入神经元和一个输出神经元构成，也就是一个逻辑模型。给神经网络一堆数据集（分别是“输入数据集”和“我们期望的输出数据集”），一般通过反向传播算法来训练前馈神经网络。 这就是监督式学习，与之相反的是无监督学习：我们只给输入，然后让神经网络去寻找数据当中的规律，反向传播的误差往往是神经网络当前输出和给定输出之前差值的某种变体（比如MSE或者仅仅是差值的现行变化）。如果神经网络具有足够的隐层神经元，那么理论上它总是能够建立输入数据和输出数据之间的关系，在实践中，FFNN的使用具有很大的局限性，但是它们通常和其他神经网络一起组合成新的架构（说明神经网络是可以相互组合的）。 反向传播算法介绍。 参考文献-反正我是看不懂的]]></content>
      <categories>
        <category>Meachine learning</category>
      </categories>
      <tags>
        <tag>neuralNet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[混合运算]]></title>
    <url>%2Fmixcalculate%2F</url>
    <content type="text"><![CDATA[一. 入门通常我们所看到的算术表达式，运算符总是在两个操作数中间(除)，如(A+B)C，这样的表达式叫做 中缀表达式这种表达式不同的运算符优先级不同，而且通常含有括号，计算机很难理解这种表达式。在编译系统中，要把人易于理解的表达式翻译成能正确求值的机器指令。编译系统中对中缀形式的算术表达式的处理方式是: 先把中缀表达式转换成后缀表达式，再进行计算。后缀表达式 就是表达式中的运算符号出现在操作数的后面，并且不含 括号 ，如AB+C。后缀表达式的特点： 后缀表达式让操作数和中缀表达式的操作数先后次序相同，只是运算符号的先后次序改变。 后缀表达式中没有括号，运算次序就是其执行次序 一个中缀表达式的四则运算规则： 1.先乘除后加减 2.先括号内在括号外 3.同级别先左后右 以A+(B-C/D)E 为例，它的后缀表达式为： ABCD/-E+其运算次序为：T1=CD/;T2 = BT1-;T3 =T2E*;T4=AT3+;基于后缀表达式的两个特点，计算过程如下:计算时只要从左到右依次扫描后缀表达式的各个单词，当读到的单词为运算符时，就运算的该运算符前两个操作数，然后讲结果T插入到后缀表达式重复上面的操作。 补充知识栈（Stack） 想象成一个箱子，后来的放在最上面，先进后出；队列（Queue）想象成一条路，一个入口一个出口，先进先出；栈和队列是两种受限的线性表。（线性表：一种线性结构，含有N&gt;=0个节点的有限序列，同一个线性表中的数据元素数据类型相同并且满足一对一的逻辑关系。）（受限表现在，栈的插入和删除操作只允许在表的尾端进行，即栈顶，满足First In Last Out；队列只允许在表尾插入数据元素，在表头删除数据元素，满足First In First Out） 二.中缀表达式转后缀表达式####1. 规则中缀表达式 a+b c + ( d e + f ) g ，其转换成后缀表达式为 a b c + d e f + g +具体过程如下：1） 遇到操作数，直接输出2） 遇到操作符，则放到栈中，遇到左括号也放入栈中3） 遇到右括号，则将栈元素弹出，将弹出的操作符输出到左括号位置，注意，括号只弹出不输出4） 遇到操作符的优先级低于或等于栈顶操作符，则弹出直至为空或发现比遇到的操作符更低优先级的，括号的优先级是最高的5） 当读到末尾，则将栈中所有的元素依次弹出6） 理解栈的优先级，栈顶最高，依次下降 ####2.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123public static string midToRPN(string tmp) &#123; var sRet = &quot;&quot;;//后缀表达式 var stringArr = SplitFunc(tmp).Split(new char[] &#123; &apos;\n&apos; &#125;, StringSplitOptions.RemoveEmptyEntries); var strstk = new Stack&lt;string&gt;(); for (int i = 0; i &lt; stringArr.Length; i++) &#123; var item = stringArr[i]; if (!string.IsNullOrEmpty(item)) &#123; if (!IsOp(item)) &#123; sRet += item + &quot;,&quot;; &#125; else &#123; if (strstk.Count == 0 || item == &quot;(&quot;) &#123; strstk.Push(item); &#125; else if (item == &quot;)&quot;) &#123; while (strstk.Peek() != &quot;(&quot;) &#123; sRet += strstk.Pop() + &quot;,&quot;; &#125; strstk.Pop();//( 出栈 &#125; else &#123; var comRes = comOper(item, strstk.Peek()); if (comRes &gt; 0) &#123; strstk.Push(item); &#125; else &#123; while (strstk.Count &gt; 0 &amp;&amp; strstk.Peek() != &quot;(&quot; &amp;&amp; comOper(item, strstk.Peek()) &lt;= 0) &#123; sRet += strstk.Pop() + &quot;,&quot;; &#125; strstk.Push(item); &#125; &#125; &#125; &#125; &#125; while (strstk.Count &gt; 0) &#123; sRet += strstk.Pop() + &quot;,&quot;; &#125; return sRet; &#125; /// &lt;summary&gt; /// 借助\n 实现将字符串转换为数组 /// &lt;/summary&gt; /// &lt;param name=&quot;tmp&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static string SplitFunc(string tmp) &#123; if (!string.IsNullOrEmpty(tmp)) &#123; tmp = tmp.Replace(&quot;+&quot;, &quot;\n+\n&quot;); tmp = tmp.Replace(&quot;-&quot;, &quot;\n-\n&quot;); tmp = tmp.Replace(&quot;*&quot;, &quot;\n*\n&quot;); tmp = tmp.Replace(&quot;/&quot;, &quot;\n/\n&quot;); tmp = tmp.Replace(&quot;(&quot;, &quot;\n(\n&quot;); tmp = tmp.Replace(&quot;)&quot;, &quot;\n)\n&quot;); &#125; return tmp; &#125; /// &lt;summary&gt; /// 是否为数字，整数 /// &lt;/summary&gt; /// &lt;param name=&quot;tmp&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool IsNumber(string tmp) &#123; //int res; //return int.TryParse(tmp, out res); return Regex.IsMatch(tmp, @&quot;[0-9]+[.]&#123;0,1&#125;[0-9]*&quot;); &#125; /// &lt;summary&gt; /// 判断是否为操作符 /// 简易计算，复杂的还需继续优化 /// &lt;/summary&gt; /// &lt;param name=&quot;tmp&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool IsOp(string tmp) &#123; var ops = new string[] &#123; &quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;, &quot;(&quot;, &quot;)&quot; &#125;; return ops.Contains(tmp); &#125; /// &lt;summary&gt; /// 比较操作符 /// &lt;/summary&gt; /// &lt;param name=&quot;op1&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;op2&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;1：大于 -1：小于 0：等于&lt;/returns&gt; public static int comOper(string op1, string op2) &#123; var res = 0; Dictionary&lt;string, int&gt; dic = new Dictionary&lt;string, int&gt;(); dic.Add(&quot;+&quot;, 1); dic.Add(&quot;-&quot;, 1); dic.Add(&quot;*&quot;, 2); dic.Add(&quot;/&quot;, 2); dic.Add(&quot;(&quot;, 100); dic.Add(&quot;)&quot;, 100); if (dic[op1] &gt; dic[op2]) res = 1; else if (dic[op1] &lt; dic[op2]) res = -1; return res; &#125; ###三.后缀表达式计算结果 ####1.规则循环后缀表达式，遇到数字压入栈中，遇到操作符，从栈中依次取出两个栈顶元素，计算结果后重新压入栈中，直至表达式结束。 ####2.代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/// &lt;summary&gt;/// 借助stack 实现运算/// &lt;/summary&gt;/// &lt;param name=&quot;tmp&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static string calRPN(string tmp)&#123; var stack = new Stack&lt;string&gt;(); var RPNArr = tmp.Split(new char[] &#123; &apos;,&apos; &#125;, StringSplitOptions.RemoveEmptyEntries); foreach (var item in RPNArr) &#123; if (!IsOp(item)) &#123; stack.Push(item); &#125; else &#123; stack.Push(CalResult(item, stack.Pop(), stack.Pop()).ToString()); &#125; &#125; return stack.Pop();&#125;/// &lt;summary&gt;/// 根据操作符计算结果/// 注意传入值/// &lt;/summary&gt;/// &lt;param name=&quot;op&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;val1&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;val2&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static double CalResult(string op, string val1, string val2)&#123; var res = 0.0; switch (op) &#123; case &quot;+&quot;: res = double.Parse(val2) + double.Parse(val1); break; case &quot;-&quot;: res = double.Parse(val2) - double.Parse(val1); break; case &quot;*&quot;: res = double.Parse(val2) * double.Parse(val1); break; case &quot;/&quot;: if (double.Parse(val1) != 0.0) res = double.Parse(val2) / double.Parse(val1); break; &#125; return res;&#125; ###Done.]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.netCore 基础]]></title>
    <url>%2Fdotnetcore%2F</url>
    <content type="text"><![CDATA[一、入门1.开发前准备（1）VScode（2）.Net Core Sdk (windows 环境 需要安装.NetFramework 4.7)（3）需要在VsCode 中安装 C# 扩展 2..netCore 优点ASP.NET Core 具有如下优点： 生成 Web UI 和 Web API 的统一场景。 集成新式客户端框架和开发工作流。 基于环境的云就绪配置系统。 内置依赖项注入。 轻型的高性能模块化 HTTP 请求管道。 能够在 IIS、Nginx、Apache、Docker 上进行托管或在自己的进程中进行自托管。 定目标到 .NET Core 时，可以使用并行应用版本控制。 简化新式 Web 开发的工具。 能够在 Windows、macOS 和 Linux 进行生成和运行。 开放源代码和以社区为中心。 .NetCore 通过命令创建项目，如：dotnet new mvc //新建mvc 项目（官网命令行介绍）Mvc 入门文档]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>.NetCore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EntityFramework]]></title>
    <url>%2Fef%2F</url>
    <content type="text"><![CDATA[1.Entity Framework 基础 DbContext:是EF中的一个类，可以理解为一个数据库对象的实例，是实体类与数据库之间的桥梁，在EF中，对数据库的操作都是通过DbContext来进行操作的。DbContext 主要负责以下：（1） EntitySet:DbConext 包含映射到数据库表的所有实体的实体集（DbSet）（2） 查询（Querying）可以使用sql语句进行查询（3） 更改跟踪（Change Tracking） 跟踪实体在从数据库查询后发生的更改（4） 持久数据（Persisting Data） 根据实体的状态对数据库进行插入、更新、删除操作（5） 缓存（Caching）默认进行一级缓存，它存储在上下文类生命周期中已经被检索的实体（6） 管理管理（Manage Relationship） DbContext还使用DB-First或Model-First方法使用CSDL，MSL和SSDL或者使用Code-First方法使用流利的API来管理关系 创建EF框架的上下文，保证线程内唯一1234567891011public static DbContext GetCurrentDbContext() &#123; //CallContext：是线程内部唯一的独用的数据槽（一块内存空间） DbContext dbContext = CallContext.GetData(&quot;DbContext&quot;) as DbContext; if (dbContext == null) &#123; dbContext = new WorkFlow_ManagerEntities(); CallContext.SetData(&quot;DbContext&quot;, dbContext); &#125; return dbContext; &#125; （7） 对象实现（Object Materialization） 将原始表数据转换为实体对象 2.Entity有五种状态： Added（增加） entity 将会被context跟踪，但是还没有新增到数据库。 Unchanged（未变动） entity 已经存在数据库并且会被context 跟踪，entity的属性值与数据库中一致，没有变动。 Modified（修改） entity 已经存在数据库并且会被context 跟踪，entity的属性值被修改了。 Deleted（删除） entity 已经存在数据库并且会被context 跟踪，但是已经被标记将在下一次SaveChanegs 的时候从数据库中删除。 Detached（分离的） entity不会被context跟踪。 3.当entity处于不同的状态时，SaveChange做出不同的动作： Unchanged 状态下，将不会向数据库发送Update 指令 Added 将会在数据库中插入记录，返回之后便会Unchanged 状态。 Modified 将会在数据库中插入记录，返回之后便会Unchanged 状态。 Deleted 将会在数据库中删除记录，返回之后变为Detached 状态 4.EF 增删改查（1） 新增实体1234567891011121314151617181920212223241.第一中写法using (var context = new Context()) &#123; var blog = new Blog &#123; Name = &quot;ADO.NET Blog&quot; &#125;; context.Blogs.Add(blog); context.SaveChanges(); &#125;2.第二种写法using (var context = new Context()) &#123; var blog = new Blog &#123; Name = &quot;ADO.NET Blog&quot; &#125;; context.Entry(blog).State = EntityState.Added; context.SaveChanges(); &#125;3.结合反射的写法using (var context = new Context()) &#123; var t = typeof(Blog); var obj = Activator.CreateInstance(t); var property = t.GetProperty(&quot;name&quot;);//获取对应属性对象 property.SetValue(obj,&quot;ADO.NET Blog&quot; ,null); context.Entry(obj).State = EntityState.Added; context.SaveChanges(); &#125; （2）向上下文附加一个已存在的实体 如果你有一个已经在数据库中存在的，但是并未被现有的context跟踪的实体，你可以告诉context通过DbSet的Attach方案来跟踪这个entity。这个entity在context中将会被设置为未变动状态。例如：123456789101112131415161718192021221.第一种写法var existingBlog = new Blog &#123; BlogId = 1, Name = &quot;ADO.NET Blog&quot; &#125;; using (var context = new BloggingContext()) &#123; context.Blogs.Attach(existingBlog); // Do some more work... context.SaveChanges(); &#125;【注意】如果没有对附加的entit进行任何其他的操作，当调用SaveChanges方法时，数据库将不会有任何修改。这是因为entity处于未变动状态。2.第二种写法var existingBlog = new Blog &#123; BlogId = 1, Name = &quot;ADO.NET Blog&quot; &#125;; using (var context = new BloggingContext()) &#123; context.Entry(existingBlog).State = EntityState.Unchanged; // Do some more work... context.SaveChanges(); &#125; （3） 在上下文中附加一个已存在、但修改的实体如果你有一个已经在数据库中存在的，但是已经做了修改的entity，你应该告诉context附加这个entity并设置状态为修改的。例如：12345678910var existingBlog = new Blog &#123; BlogId = 1, Name = &quot;ADO.NET Blog&quot; &#125;; using (var context = new BloggingContext()) &#123; context.Entry(existingBlog).State = EntityState.Modified; // Do some more work... context.SaveChanges(); &#125;当你变更状态为修改的，entity的所有属性将会被标记为修改的，并且当SaveChanges方法被调用时，所有属性值都会传递给数据库。 （4）变更被跟踪的实体状态你可以通过设置State属性来变更被跟踪的entity状态，例如： 1234567891011var existingBlog = new Blog &#123; BlogId = 1, Name = &quot;ADO.NET Blog&quot; &#125;; using (var context = new BloggingContext()) &#123; context.Blogs.Attach(existingBlog); context.Entry(existingBlog).State = EntityState.Unchanged; // Do some more work... context.SaveChanges(); &#125;【注意】在已经被跟踪的entity上新增或附加一个新的entity也将会改变entity的状态。例如，在一个处于新增状态的entity上附加一个新的entity将会改变他们的状态为未修改 （5）更新实体 1234567891011121314151617181.第一种写法 using (var context = new BloggingContext()) &#123; var blog = context.FirstOrDefault(); blog.Name =&quot;test&quot;; context.Entry(blog).State = EntityState.Modified; //可加可不加 context.SaveChanges(); &#125; 2.结合反射 using (var context = new BloggingContext()) &#123; var blog = context.FirstOrDefault(); var t = blog.GetType(); var property = t.GetProperty(&quot;name&quot;);//获取对应属性对象 property.SetValue(blog,&quot;ADO.NET Blog&quot; ,null); context.Entry(blog).State = EntityState.Modified; //可加可不加 context.SaveChanges(); &#125; ###Done.]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>EF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射]]></title>
    <url>%2Freflection%2F</url>
    <content type="text"><![CDATA[1.简介反射 提供了封装程序集、模块和类型的对象（Type类型）。可以使用反射动态创建类型的实例，将类型绑定到现有对象，或从现有对象获取类型并调用其方法或访问其字段和属性。如果代码中使用了特性，可以利用反射对它们进行访问。 2.反射的用途 （1）使用Assembly定义和加载程序集，加载在程序集清单中列出模块，以及从此程序集中查找类型并创建该类型的实例。 （2）使用Module了解包含模块的程序集以及模块中的类等，还可以获取在模块上定义的所有全局方法或其他特定的非全局方法。 （3）使用ConstructorInfo了解构造函数的名称、参数、访问修饰符（如pulic 或private）和实现详细信息（如abstract或virtual）等。 （4）使用MethodInfo了解方法的名称、返回类型、参数、访问修饰符（如pulic 或private）和实现详细信息（如abstract或virtual）等。 （5）使用FiedInfo了解字段的名称、访问修饰符（如public或private）和实现详细信息（如static）等，并获取或设置字段值。 （6）使用EventInfo了解事件的名称、事件处理程序数据类型、自定义属性、声明类型和反射类型等，添加或移除事件处理程序。 （7）使用PropertyInfo了解属性的名称、数据类型、声明类型、反射类型和只读或可写状态等，获取或设置属性值。 （8）使用ParameterInfo了解参数的名称、数据类型、是输入参数还是输出参数，以及参数在方法签名中的位置等。 3.反射涉及的类1.Namespace System.Reflection System.Type System.Reflection.Assembly 2. Class System.Type 类－－通过这个类可以访问任何给定数据类型的信息。 System.Reflection.Assembly类－－它可以用于访问给定程序集的信息，或者把这个程序集加载到程序中。 3. System.Type 类 System.Type 类对于反射起着核心的作用。但它是一个抽象的基类，Type有与每种数据类型对应的派生类，我们使用这个派生类的对象的方法、字段、属性来查找有关该类型的所有信息。 获取给定类型的Type引用有3种常用方式： ●使用 C# typeof 运算符。 Type t = typeof(string); ●使用对象GetType()方法。 string s = &quot;grayworm&quot;; Type t = s.GetType(); ●还可以调用Type类的静态方法GetType()。 Type t = Type.GetType(&quot;System.String&quot;); Type 属性： Name 数据类型名 FullName 数据类型的完全限定名(包括命名空间名) Namespace 定义数据类型的命名空间名 IsAbstract 指示该类型是否是抽象类型 IsArray 指示该类型是否是数组 IsClass 指示该类型是否是类 IsEnum 指示该类型是否是枚举 IsInterface 指示该类型是否是接口 IsPublic 指示该类型是否是公有的 IsSealed 指示该类型是否是密封类 IsValueType 指示该类型是否是值类型 Type类的方法： GetConstructor(), GetConstructors()：返回ConstructorInfo类型，用于取得该类的构造函数的信息 GetEvent(), GetEvents()：返回EventInfo类型，用于取得该类的事件的信息 GetField(), GetFields()：返回FieldInfo类型，用于取得该类的字段（成员变量）的信息 GetInterface(), GetInterfaces()：返回InterfaceInfo类型，用于取得该类实现的接口的信息 GetMember(), GetMembers()：返回MemberInfo类型，用于取得该类的所有成员的信息 GetMethod(), GetMethods()：返回MethodInfo类型，用于取得该类的方法的信息 GetProperty(), GetProperties()：返回PropertyInfo类型，用于取得该类的属性的信息 可以调用这些成员，其方式是调用Type的InvokeMember()方法，或者调用MethodInfo, PropertyInfo和其他类的Invoke()方法。 4.例子，便于理解1. Demo(动态实例化对象)123456789101112131415161718using Systme.Reflection.Assemblypublic static T CreateInstance&lt;T&gt;(string fullName,string assemblyName)&#123;string path = fullName +&quot;,&quot;+assemblyName;//命名空间.类型名，程序集Type o = Type.GetType(path)://加载类型object obj = Activator.CreateInstance(o,true);//根据类型创建实例return (T)obj;//类型转换并返回&#125;public static T CreateInstance&lt;T&gt;(string assemblyName,string nameSpace,string className)&#123;try &#123;string fullName = nameSpace+&quot;.&quot;+className;//第一种写法object obj = Assembly.Load(assemblyName).CreateInstance(fullName);return (T)obj;&#125;&#125; 2. 属性的使用12345678910111213141516171819202122232425public class TestClass &#123;//属性 public string name &#123; get; set; &#125; public string mail &#123; get; set; &#125; &#125;class Program &#123; static void Main(string[] args) &#123; var t = typeof(TestClass);//返回Type var obj = Activator.CreateInstance(t);//用Activator生成对象 创建实例 object 类型 //查看所有属性 PropertyInfo[] piArray = t.GetProperties(); foreach (PropertyInfo pi in piArray) &#123; Console.WriteLine(pi.Name); &#125; var properName = t.GetProperty(&quot;name&quot;);//获取属性 properName.SetValue(obj,&quot;dd&quot;);//赋值 var properMail = t.GetProperty(&quot;mail&quot;); properMail.SetValue(obj,&quot;mail&quot;); var model = (TestClass) obj; //强制转换为实体 &#125; &#125; 3. 字段和方法的使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 public class TestClass &#123; public int age; public string name; public string myProper &#123; get; set; &#125; //不带参数的公共方法 public resMod NoParPrint() &#123; return new resMod() &#123; res = name + age + myProper &#125;; &#125; //带参数的公共方法 public string printMsg(string test) &#123; return name + age; &#125; //无参数静态方法 public static string StaticNoParPrint() &#123; return &quot;无参数静态方法&quot;; &#125; //带参数的静态方法 public static string StaticParPrnt(string input) &#123; return input + &quot;1212&quot;; &#125; &#125; public class resMod &#123; public string res &#123; get; set; &#125; &#125;class Program &#123; static void Main(string[] args) &#123; var t = typeof(TestClass); var obj = Activator.CreateInstance(t); var ageField = t.GetField(&quot;age&quot;); var nameField = t.GetField(&quot;name&quot;); var myProper = t.GetProperty(&quot;myProper&quot;); myProper.SetValue(obj,&quot;Pro&quot;); ageField.SetValue(obj, 123); nameField.SetValue(obj, &quot;w de name&quot;); var methodPrint = t.GetMethod(&quot;NoParPrint&quot;); //调用方法，res为返回值，此处为object类型，可转换为resMod,但有装箱拆箱操作 //避免消耗，可使用list&lt;&gt; var res = methodPrint.Invoke(obj, null); object[] pars = new object[]&#123;&quot;test&quot;&#125;; methodPrint = t.GetMethod(&quot;printMsg&quot;); res = methodPrint.Invoke(obj, pars); methodPrint = t.GetMethod(&quot;StaticNoParPrint&quot;); //静态方法 不需要实例对象 res = methodPrint.Invoke(null, null); methodPrint = t.GetMethod(&quot;StaticParPrnt&quot;); res = methodPrint.Invoke(null, pars); &#125; &#125; 4. System.Reflection.Assembly类的用法1、通过程序集名称返回Assembly对象 Assembly assembly = Assembly.Load(&quot;ReflectionDemo2&quot;); 2、通过DLL文件名称返回Assembly对象 Assembly assembly = Assembly.LoadFrom(&quot;ReflectionDemo2.dll&quot;); 3、通过Assembly获取程序集中类 Type t = assembly.GetType(&quot;ReflectionDemo2.ReflectionClass&quot;); //参数必须是类的全名 4、通过Assembly获取程序集中所有的类 Type[] tArray = assembly.GetTypes();5、通过程序集的名称反射 Assembly assembly = Assembly.Load(&quot;ReflectionDemo2&quot;); Type t = assembly.GetType(&quot;ReflectionDemo2.ReflectionClass&quot;); //参数必须是类的全名 object o = Activator.CreateInstance(t,&quot;男&quot;); MethodInfo mi = t.GetMethod(&quot;Show&quot;); mi.Invoke(o,null); 6、通过DLL文件全名反射其中的所有类型123456789Assembly assembly = Assembly.LoadFrom(&quot;ReflectionDemo2.dll&quot;);Type[] tArray = assembly.GetTypes();foreach (Type t in tArray)&#123; if (t.FullName == &quot;a.b.c&quot;) &#123; object o = Activator.CreateInstance(t); &#125;&#125; ###Done.]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>Reflection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js_juicer]]></title>
    <url>%2Fjs-juicer%2F</url>
    <content type="text"><![CDATA[1.简介Juicer 是一个高效、轻量的前端模版引擎，好处可以在前端页面使得视图模型与数据的分离。（可以运行在node.js ） 2.使用1.引用1).Install:：npm i juicer2).下载代码地址：Github Link项目中引用：&lt;script type=&quot;text/javascript&quot; src=&quot;juicer-min.js&quot;&gt;&lt;/script&gt;2.一般使用1.语法12345678910111213141516171819202122232425262728293031323334a.使用$&#123;&#125; 输出变量，支持自定义函数$&#123;name&#125;$&#123;name|function&#125;//自定义的函数var testFun = function(data)&#123; return &apos;&lt;a href=&quot;&apos;+data.href+&apos;&quot; alt = &quot;&apos;+data.alt+&apos;&quot;/&gt;&apos;&#125;//注册/注销自定义函数//jucer.register(&apos;function name&apos;,function)juicer.register(&apos;test_Fun&apos;,testFun)//juicer.unregister(&apos;test_Fun&apos;)var json = &#123; links: [ &#123;href: &apos;http://juicer.name&apos;, alt: &apos;Juicer&apos;&#125;, &#123;href: &apos;http://benben.cc&apos;, alt: &apos;Benben&apos;&#125;, &#123;href: &apos;http://ued.taobao.com&apos;, alt: &apos;Taobao UED&apos;&#125; ]&#125;;var tpl= [ &apos;&#123;@each links as item &#125;&apos;, &apos;$&#123;item|test_Fun&#125; &lt;br/&gt;&apos;, &apos;&#123;@/each&#125;&apos;].join(&apos;&apos;)//编译模版并根据所给数据立即渲染结果juicer(tpl,json)//先编译，返回函数，再渲染数据var compiled_tpl = juicer(tpl);var htm = compiled_tpl.render(data);//转义问题使用$$&#123;变量&#125;避免转义 1234567891011121314b.循环和判断&#123;@each list as item&#125; $&#123;item.变量&#125;&#123;@/each&#125; &#123;@each list as item,index&#125; &#123;@if index===3&#125; the index is 3, the value is $&#123;item.prop&#125; &#123;@else if index === 4&#125; the index is 4, the value is $&#123;item.prop&#125; &#123;@else&#125; the index is not 3, the value is $&#123;item.prop&#125; &#123;@/if&#125;&#123;@/each&#125; 123456c.注释&#123;# 注释类容&#125;d.辅助循环&#123;@each i in range(5, 10)&#125; $&#123;i&#125;; //输出 5;6;7;8;9;&#123;@/each&#125; 1234567891011121314151617181920212223e.子模板嵌套 &#123;@include tpl, data&#125;//Html 代码&lt;script type=&quot;text/juicer&quot; id=&quot;subTpl&quot;&gt; I&apos;m sub content, $&#123;name&#125;&lt;/script&gt;//js 代码var tpl = &apos;Hi, &#123;@include &quot;#subTpl&quot;, subData&#125;, End.&apos;; juicer(tpl, &#123; subData: &#123; name: &apos;juicer&apos; &#125;&#125;); //输出 Hi, I&apos;m sub content, juicer, End.//或者通过数据引入子模板，下述代码也将会有相同的渲染结果： var tpl = &apos;Hi, &#123;@include subTpl, subData&#125;, End.&apos;;juicer(tpl, &#123; subTpl: &quot;I&apos;m sub content, $&#123;name&#125;&quot;, subData: &#123; name: &apos;juicer&apos; &#125;&#125;); 1234567f. Node.hs 使用在命令行中执行:npm install juicer 在代码中这么引入:var juicer = require(&apos;juicer&apos;);var html = juicer(tpl, data); 3..net demo.net 项目中，使用Razor引擎。1).定义模版注意点：由于@在razor中是关键字，所以在razor中使用Juicer，需要使用@@ 代表@12345678910111213141516171819202122232425262728293031323334353637383940HTML 代码 &lt;div id=&quot;ChildCon&quot; class=&quot;row-border ChildCondition&quot;&gt; &lt;div id=&quot;Conditions&quot; style=&quot;padding: 50px 50px 50px 50px;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;row-border&quot; style=&quot;padding: 0 50px 10px 50px; margin-top: -30px;text-align:center&quot;&gt; &lt;button id=&quot;Goback&quot; class=&quot;btn btn-default pull-left&quot; title=&quot;Back&quot;&gt;&lt;i class=&quot; fa fa-arrow-left fa-xs&quot;&gt;&lt;/i&gt;&lt;/button&gt; &lt;button id=&quot;GoSearch&quot; class=&quot;btn btn-default&quot; title=&quot;Search&quot;&gt;&lt;i class=&quot; fa fa-search fa-xs&quot;&gt;&lt;/i&gt;&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;script id=&quot;tpl&quot; type=&quot;text/template&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;form-horizontal&quot;&gt; &#123;@@each list as lt&#125; &lt;div class=&quot;form-group col-lg-4&quot;&gt; &#123;@@each lt.key as lkey&#125; &lt;label class=&quot;col-sm-4 control-label noPaddingRigt&quot;&gt;$&#123;lkey.label&#125;:&lt;/label&gt; &#123;@@if lkey.type==1&#125; &lt;div class=&quot;col-sm-8&quot;&gt; &lt;select style=&quot;width: 80%&quot; class=&quot;form-control&quot;&gt; &#123;@@each lt.value as lval&#125; &#123;@@if lval.default==1&#125; &lt;option value=&quot;$&#123;lval.ovalue&#125;&quot; selected&gt;$&#123;lval.otext&#125;&lt;/option&gt; &#123;@@else&#125; &lt;option value=&quot;$&#123;lval.ovalue&#125;&quot;&gt;$&#123;lval.otext&#125;&lt;/option&gt; &#123;@@/if&#125; &#123;@@/each&#125; &lt;/select&gt; &lt;/div&gt; &#123;@@else if lkey.type==0&#125; &lt;div class=&quot;col-sm-8&quot;&gt; &lt;input id=&quot;$&#123;lkey.id&#125;&quot; style=&quot;width:80%&quot; class=&quot;form-control&quot; placeholder=&quot;$&#123;lt.value&#125;&quot; /&gt; &lt;/div&gt; &#123;@@/if&#125; &#123;@@/each&#125; &lt;/div&gt; &#123;@@/each&#125; &lt;/div&gt; &lt;/div&gt; &lt;/script&gt;` 1234567891011121314151617Js 代码 $(function () &#123; var objdata = &#123; list: [ &#123; key: [&#123; &quot;label&quot;: &quot;Conductor Material&quot;, &quot;type&quot;: &quot;1&quot; &#125;], value: [ &#123; &quot;otext&quot;: &quot;Copper and alloy 铜及合金&quot;, &quot;ovalue&quot;: &quot;Copper and alloy;铜及合金&quot;, &quot;default&quot;: 1 &#125;, &#123; &quot;otext&quot;: &quot;Aluminum and alloy 铝及合金&quot;, &quot;ovalue&quot;: &quot;Aluminum and alloy;铝及合金&quot;, &quot;default&quot;: 0 &#125;, &#123; &quot;otext&quot;: &quot;Others 其它&quot;, &quot;ovalue&quot;: &quot;Others;其它&quot;, &quot;default&quot;: 0 &#125;, &#123; &quot;otext&quot;: &quot;&quot;, &quot;ovalue&quot;: &quot;不限&quot;, &quot;default&quot;: 0 &#125; ] &#125;] var tpl = document.getElementById(&apos;tpl&apos;).innerHTML; var html = juicer(tpl, objdata); $(&quot;#Conditions&quot;).html(html);&#125;);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Juicer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js_animate]]></title>
    <url>%2Fjs-animate%2F</url>
    <content type="text"><![CDATA[1.介绍Animate.css 一个有封装好的动画效果集，跨浏览器css3动画库。效果预览即首页Github地址 2.使用1).笔记在Github里下载代码，找到Animate.css，引用到项目中；npm 安装命令 install animate.css --save```12**Basic Usage** Class Namebounce flash pulse rubberBandshake headShake swing tadawobble jello bounceIn bounceInDownbounceInLeft bounceInRight bounceInUp bounceOutbounceOutDown bounceOutLeft bounceOutRight bounceOutUpfadeIn fadeInDown fadeInDownBig fadeInLeftfadeInLeftBig fadeInRight fadeInRightBig fadeInUpfadeInUpBig fadeOut fadeOutDown fadeOutDownBigfadeOutLeft fadeOutLeftBig fadeOutRight fadeOutRightBigfadeOutUp fadeOutUpBig flipInX flipInYflipOutX flipOutY lightSpeedIn lightSpeedOutrotateIn rotateInDownLeft rotateInDownRight rotateInUpLeftrotateInUpRight rotateOut rotateOutDownLeft rotateOutDownRightrotateOutUpLeft rotateOutUpRight hinge jackInTheBoxrollIn rollOut zoomIn zoomInDownzoomInLeft zoomInRight zoomInUp zoomOutzoomOutDown zoomOutLeft zoomOutRight zoomOutUpslideInDown slideInLeft slideInRight slideInUpslideOutDown slideOutLeft slideOutRight slideOutUpheartBeat .1**Example** Example12345[Check out all the animations here](https://daneden.github.io/animate.css)*****Javascript Usage**``` 1.$(&apos;#yourElement&apos;).addClass(&apos;animated bounceOutLeft&apos;); 2.一般使用1234567891011121314151617// See https://github.com/daneden/animate.css/issues/644var animationEnd = (function(el) &#123; var animations = &#123; animation: &apos;animationend&apos;, OAnimation: &apos;oAnimationEnd&apos;, MozAnimation: &apos;mozAnimationEnd&apos;, WebkitAnimation: &apos;webkitAnimationEnd&apos;, &#125;; for (var t in animations) &#123; if (el.style[t] !== undefined) &#123; return animations[t]; &#125; &#125;&#125;)(document.createElement(&apos;div&apos;));$(&apos;#yourElement&apos;).one(animationEnd, doSomething); 3.扩展jquery 方法1234567891011121314151617181920212223242526$.fn.extend(&#123; animateCss: function(animationName, callback) &#123; var animationEnd = (function(el) &#123; var animations = &#123; animation: &apos;animationend&apos;, OAnimation: &apos;oAnimationEnd&apos;, MozAnimation: &apos;mozAnimationEnd&apos;, WebkitAnimation: &apos;webkitAnimationEnd&apos;, &#125;; for (var t in animations) &#123; if (el.style[t] !== undefined) &#123; return animations[t]; &#125; &#125; &#125;)(document.createElement(&apos;div&apos;)); this.addClass(&apos;animated &apos; + animationName).one(animationEnd, function() &#123; $(this).removeClass(&apos;animated &apos; + animationName); if (typeof callback === &apos;function&apos;) callback(); &#125;); return this; &#125;,&#125;); 扩展后使用方法：12345$(&apos;#yourElement&apos;).animateCss(&apos;bounce&apos;);or;$(&apos;#yourElement&apos;).animateCss(&apos;bounce&apos;, function() &#123; // Do somthing after animation&#125;); Define Delay and Speed using ClassYou can also add delays directly on the element’s class attribute, just like this:class12345678910Class Name|Delay Time---|:--:delay-2s|2sdelay-3s|3sdelay-4s|4sdelay-5s|5sYou can control the speed of the animation by adding these classes, as a sample below:```&lt;div class=&quot;animated bounce faster&quot;&gt;Example&lt;/div&gt; Class Name Speed Time slow 2s slower 3s fast 800ms faster 500ms ####2).运用此次用的很少一部分功能，主要是想实现的功能：主div 点击下一步 到下一个div，中间使用animiate.css 来实现动画切换，时间有限，未能详细解决，只是个折中解决方案。123456789101112131415161718//子div 先隐藏 $(&quot;#ChildCon&quot;).hide(); //主div的下拉框变化后 $(&quot;#MainType&quot;).on(&apos;change&apos;, function (data) &#123; if ($(&quot;#MainType&quot;) !== &quot;&quot;) &#123;//主div 添加动画效果，然后在回调函数中隐藏它 $(&quot;#ParentCon&quot;).animateCss(&quot;flipOutX&quot;, function () &#123; $(&quot;#ParentCon&quot;).hide();//隐藏主div //var tpl = document.getElementById(&apos;tpl&apos;).innerHTML; //var html = juicer(tpl, objdata); $(&quot;#Conditions&quot;).html(html);//子div 显示//同时添加子div 的显示动画 $(&quot;#ChildCon&quot;).show(); //$(&quot;#ChildCon&quot;).animateCss(&quot;flipInX&quot;); &#125;); &#125; &#125;); 问题:在切换之间页面会跳出滚动条，体验不怎么好~~~ #####################20180807 ####div切换时 跳出滚动条，页面抖动的解决方案：隐藏滚动条(不是解决方法的方法)1234body &#123; overflow-x: hidden; overflow-y: hidden &#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Animate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[decisionTree]]></title>
    <url>%2FdecisionTree%2F</url>
    <content type="text"><![CDATA[一、引言k-近邻算法可以完成很多分类任务，但是它最大的缺点就是无法给出数据的内在含义，决策树的主要优势就在于数据形式非常容易理解。而决策树算法能够读取数据集合，构建决策树。决策树很多任务都是为了数据中所蕴含的知识信息，因此决策树可以使用不熟悉的数据集合，并从中提取出一系列规则，机器学习算法最终将使用这些机器从数据集中创造的规则。专家系统中经常使用决策树，而且决策树给出结果往往可以匹敌在当前领域具有几十年工作经验的人类专家。 决策树的一般流程(1) 收集数据：可以使用任何方法。(2) 准备数据：树构造算法只适用于标称型数据，因此数值型数据必须离散化。(3) 分析数据：可以使用任何方法，构造树完成之后，我们应该检查图形是否符合预期。(4) 训练算法：构造树的数据结构。(5) 测试算法：使用经验树计算错误率。(6) 使用算法：此步骤可以适用于任何监督学习算法，而使用决策树可以更好地理解数据的内在含义。 机器学习中采用的ID3算法划分数据集，每次划分数据集时我们只选取一个特征属性，如果训练集中存在20个特征，第一次我们选择哪个特征作为划分的参考属性呢？ ###二、实现 优点：计算复杂度不高，输出结构易于理解，对中间值的缺失不敏感，可以处理不相关特征数据缺点：可能会产生过度匹配问题 熵表示随机变量的不确定性。 条件熵表示在一个条件下，随机变量的不确定性 信息增益=熵-条件熵 python 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import osfrom math import logimport operatorimport matplotlib.pyplot as plt #绘图# 数据源def CreatDataSet(): dataSet = [[1,1,&apos;yes&apos;], [1,1,&apos;yes&apos;], [1,0,&apos;no&apos;], [0,1,&apos;no&apos;], [0,1,&apos;no&apos;]] labels = [&apos;no surfacing&apos;,&apos;flippers&apos;] return dataSet,labels# 1.0 计算信息熵 熵越多，混合的数据越多，分类越多 熵越高def calcsShangnonEnt(dataSet): numEntries = len(dataSet) dic=&#123;&#125; for data in dataSet: currentVec = data[-1] if currentVec not in dic.keys(): dic[currentVec]=0 dic[currentVec]+=1 ShangnonEnt = 0.0 for key in dic: prob = float(dic[key])/numEntries ShangnonEnt -= prob * log(prob,2) return ShangnonEnt# 2.0 划分数据集def splitDataSet(dataSet,axis,value): retDataSet= [] for featVec in dataSet: # print(featVec[axis]) if featVec[axis] == value: reducedFeatVec = featVec[:axis] #去除特征 第i列就去除第i列数据 reducedFeatVec.extend(featVec[axis+1:]) #返回去除特征值后的List retDataSet.append(reducedFeatVec) return retDataSet#3.0 正式使用#满足的要求： 1.数据必须是一种由列表[]组成的列表[]，而且所有的列表元素要有相同的数据长度；# 2.数据的最后一列或者每个实例的最后一个元素是当前实例的列别标签 # 熵，条件熵增强理解： https://blog.csdn.net/xwd18280820053/article/details/70739368 def chooseBestFeatureToSplit(dataSet): numFeatures = len(dataSet[0])-1 #得到特征值 -1 ，最后一个是类别 baseEntropy = calcsShangnonEnt(dataSet) #计算整个数据集的原始香农熵，用于与划分之后的数据集计算的熵进行比较 bestInfoGain=0.0;bestFeature = -1 for i in range(numFeatures): featList= [example[i] for example in dataSet] #将dataset的每条数据的第i列出来 uniqueVals = set(featList) #去除重复值 newEntropy = 0.0 for value in uniqueVals: #遍历当前特征值的所有唯一属性值 subDataSet = splitDataSet(dataSet,i, value) #对每个特征划分一次数据集 prob = len(subDataSet)/float(len(dataSet)) #计算p newEntropy +=prob * calcsShangnonEnt(subDataSet)#计算条件熵 # print(newEntropy) infoGain = baseEntropy- newEntropy #计算信息增益，在一个条件下，信息不确定性减少的程度 if(infoGain&gt;bestInfoGain): bestInfoGain = infoGain bestFeature=i return bestFeaturedef majorityCnt(classList): classCount=&#123;&#125; for vote in classList: if vote not in classCount: classCount[vote] = 0; classCount[vote]+=1 soredClassCount = sorted(clssCount.items(),key=operator.itemgetter(1),reverse=True) return soredClassCount[0][0]#递归 分类后的结果def createTree(dataSet,labels): classList = [example[-1] for example in dataSet] if classList.count(classList[0])==len(classList): return classList[0] if len(dataSet[0])==1: return majorityCnt(classList) bestFeat = chooseBestFeatureToSplit(dataSet) bestFeatLable= labels[bestFeat] myTree = &#123;bestFeatLable:&#123;&#125;&#125; del(labels[bestFeat]) featValues = [data[bestFeat] for data in dataSet] uniqueVals = set(featValues) for val in uniqueVals: subLabels = labels[:] myTree[bestFeatLable][val] = createTree(splitDataSet(dataSet,bestFeat,val),subLabels) return myTree 三、绘图12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576###############绘图#############获取叶节点def getNumLeafs(myTree): numLeafs =0 firstStr = list(myTree.keys())[0] secondDict = myTree[firstStr] for key in secondDict.keys(): if type(secondDict[key]).__name__==&apos;dict&apos;: numLeafs += getNumLeafs(secondDict[key]) else: numLeafs +=1 return numLeafsdef getTreeDepth(myTree): maxDepth = 0 firstStr= list(myTree.keys())[0] secondDict=myTree[firstStr] for key in secondDict.keys(): if type(secondDict[key]).__name__==&apos;dict&apos;: thisDepth =1+getTreeDepth((secondDict[key])) else: thisDepth =1 if thisDepth&gt;maxDepth:maxDepth = thisDepth return maxDepthdef plotMidText(cntrPt,parentPt,txtString): xMid=(parentPt[0]-cntrPt[0])/2.0 + cntrPt[0] yMid=(parentPt[1]-cntrPt[1])/2.0 + cntrPt[1] createPlot.ax1.text(xMid,yMid,txtString)decisionNode = dict(boxstyle=&quot;sawtooth&quot;, fc=&quot;0.8&quot;)arrow_args = dict(arrowstyle=&quot;&lt;-&quot;)leafNode = dict(boxstyle=&quot;round4&quot;, fc=&quot;0.8&quot;)def plotNode(nodeTxt, centerPt, parentPt, nodeType): # annotate是关于一个数据点的文本 # nodeTxt为要显示的文本，centerPt为文本的中心点，箭头所在的点，parentPt为指向文本的点 createPlot.ax1.annotate(nodeTxt, xy=parentPt, xycoords=&apos;axes fraction&apos;, xytext=centerPt, textcoords=&apos;axes fraction&apos;, va=&quot;center&quot;, ha=&quot;center&quot;, bbox=nodeType, arrowprops=arrow_args )def plotTree(myTree,parentPt,nodeTxt): numLeafs= getNumLeafs(myTree) depth = getTreeDepth(myTree) firstStr = list(myTree.keys())[0] cntrPt = (plotTree.xOff+(1.0 +float(numLeafs))/2.0/plotTree.totalW,plotTree.yOff) plotMidText(cntrPt,parentPt,nodeTxt) plotNode(firstStr,cntrPt,parentPt,decisionNode) secondDict = myTree[firstStr] plotTree.yOff = plotTree.yOff -1.0/plotTree.totalD for key in secondDict.keys(): if type(secondDict[key]).__name__==&apos;dict&apos;: plotTree(secondDict[key],cntrPt,str(key)) else: plotTree.xOff = plotTree.xOff +1.0/plotTree.totalW plotNode(secondDict[key],(plotTree.xOff,plotTree.yOff),cntrPt,leafNode) plotMidText((plotTree.xOff,plotTree.yOff),cntrPt,str(key)) plotTree.yOff = plotTree.yOff +1.0/plotTree.totalDdef createPlot(inTree): fig = plt.figure(1, facecolor=&apos;white&apos;) fig.clf() axprops = dict(xticks=[], yticks=[])# 定义横纵坐标轴，无内容 #createPlot.ax1 = plt.subplot(111, frameon=False, **axprops) # 绘制图像,无边框,无坐标轴 createPlot.ax1 = plt.subplot(111, frameon=False) plotTree.totalW = float(getNumLeafs(inTree)) #全局变量宽度 = 叶子数 plotTree.totalD = float(getTreeDepth(inTree)) #全局变量高度 = 深度 #图形的大小是0-1 ，0-1 plotTree.xOff = -0.5/plotTree.totalW; #例如绘制3个叶子结点，坐标应为1/3,2/3,3/3 #但这样会使整个图形偏右因此初始的，将x值向左移一点。 plotTree.yOff = 1.0; plotTree(inTree, (0.5,1.0), &apos;&apos;) plt.show()##############绘图结束###############]]></content>
      <categories>
        <category>Meachine learning</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K-近邻算法]]></title>
    <url>%2FK-%E8%BF%91%E9%82%BB%2F</url>
    <content type="text"><![CDATA[1.概述 简单来书，K-近邻算法就是采用测量不同特征值之间距离的方法来分类的。 此笔记是根据《机器学习》书中介绍的KNN。在包含特征值的训练样本集中，输入没有特征的新数据后，将新数据每个特征与训练集对应特征进行比较，然后提取最相似数据的分类标签，一般来说只选择训练集中前k个最相似的数据，通常k不大于20的整数，最后统计次数最多的分类标签即为新数据的标签。 《机器学习》数据源 2.介绍优点：精度高，对异常值不敏感，无数据输入假定缺点：计算复杂度高，控件复杂度高适用数据范围：数值型和标称型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from numpy import * #引用所有numpy#1.导入数据源，解析文本记录def file2matrix(filename): fr = open(filename) arrayLines = fr.readlines() numberOfLines = len(arrayLines) returnMat = zeros((numberOfLines,3)) #返回由0填充的数组 labelVec =[] #数据类别 index = 0 for line in arrayLines: line = line.strip() #删除字符串头尾的指定字符（默认空格或换行符） listFromLine = line.split(&apos;\t&apos;) returnMat[index,;] = listFromLine[0:3] labelVex.append(int(listFromLine[-1])) index +=1 return returnMat,labelVec#2.归一化特征值 newVals = (oldVals - minVals)/(maxVals - minVals)def autoNorm(dataSet): minVals = dataSet.min(0) #0:列 1:行 min(0):每一列的最小值 maxVals= dataSet.max(0) #返回的是行数据 ranges = maxVals - minVals m= dataSet.shape[0] normDataSet = zeros((shape(dataSet))) # shape(dataSet) 得到(行，列)，即复制数组结构 normDataSet = dataSet - tile(minVals,(m,1)) #tile(data,(行，1)) 复制数据，m行 normDataSet = normDataSet/tile(ranges,(m,1)) return normDataSet,ranges,minVals#3.k-近邻算法 平方差公式def classify(inx,dataSet,Labels,k): m = dataSet.shape[0] #获取dataSet的行 copyInxArray= tile(inx,(m,1)) diffMat = pow(dataSet - copyInxArray,2) #差的平方 #sum 与axis 连用时，axis=0 每一列数据相加；axis=1 每一行数据相加， 结果都是一个一维数组； #当max/min与axis 连用时，axis=0 取出每一行的最大值，保持列数；axis=1时，取出每一列的最大值，保持行数 sumDiffMat = diffMat.sum(axis=1) Distance = sumDiffMat ** 0.5 sortedDistance = distance.argsort() #1.标注对应索引。2.对数据升序排序。3.返回升序结果后对应的索引 classCount =&#123;&#125; for i in range(k): votes = Labels[sortedDistance[k]] classCount[vote] = classCount.get(vote,0)+1 #计算label出现的次数 #按照value(次数)排序，需要引用 import operator，返回由tuple组成的List sortedClassCount = sorted(classCount.items(),key = operator.itemgetter(1),reverse = True) return sortedClassCount[0][0]#4.data testdef datingClassTest(): ratio = 0.10 #测试数据比例 dataMat,labels = file2matrix(&apos;test.txtx&apos;) normdataMat,ranges,minVals= autoNorm(dataMat) m = normdataMat.shape[0] numTestData = int(m*ratio) errorCount = 0.0 for i in range(numTestData): TestClassify =classify(dataMat[i],dataMat[numTestData:m:],labels[numTestData:m:],3) print(&quot;classify type:%s,the real answer is %s&quot; % (TestClassify,labels[i])) if(TestClassify!=labels[i]): errorCount +=1.0 pring(&quot;the error rate %f&quot;%(errorCount/float(numTestData))) Done.]]></content>
      <categories>
        <category>Meachine learning</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F404%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[机器学习基础]]></title>
    <url>%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1.基础概念 《机器学习》:简单而言，机器学习就是把无序的数据转换成有用的信息。 1.学习形式分类 监督学习(supervised learning) 监督学习即在机械学习过程中给出对错提示，从给定带有标签的训练集中训练出目标函数，主要应用于分类和预测（classify &amp; regression）。通常的算法包含回归分析和统计分类 非监督学习(unsupervised learning) 学习没有标签的数据集，比如在分析大量语句之后，训练出一个模型将较为接近的词分为一类，而后可以根据一个新的词在句子中的用法（和其他信息）将这个词分入某一类中。其中比较微妙的地方在于，这种问题下使用聚类（Clustering）（方法）所获得的簇（Cluster）（结果），有时候是无法人为地观察出其特征的，但是在得到聚类后，可能会对数据集有新的启发2.数据相关 用来进行机器学习的一个数据集往往会被分为两个数据集——训练数据（training data）和测试数据（testing data）。 顾名思义，训练数据在机器学习的过程中使用，目的是找出一套机器学习的方法；而测试数据用于判断找出的方法是否足够有效。]]></content>
      <categories>
        <category>Meachine learning</category>
      </categories>
      <tags>
        <tag>Basic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性回归、Logistic回归]]></title>
    <url>%2FRegression%2F</url>
    <content type="text"><![CDATA[1. 概念回归(Regression) 《机器学习》：假设现有一些数据点，我们用一条线去对这些点拟合，该线称为最佳拟合直线，这个拟合的过程为回归。 2.线性回归（Linear Regression）2.1 线性回归模型与解决方案例：训练集 房屋面积与价格的数据表，预测其他不同面积的房屋的价格？需要得到的结果是具体的数值。方案：将现有数据在图中标记后，拟合出一条合理的曲线（在这里是一条直线），然后用这条曲线预测新的房屋面积对应的价格。 h(Hypothesis) 假设函数如下:$$h_\theta(x) =\sum_{i=0}^nθ_ix_i=\theta^T x$$公式里的参数$\theta$和输入x都被视为向量，即$\theta^T$=[$\theta_0$ $\theta_1$ $\cdots$ $\theta_n$],$x$=$\begin{bmatrix} x_0\x_1\ \vdots\x_n \end{bmatrix}$ 对于给定的x ，f(x)与真实值Y可能具有差异，为表示拟合的好坏，用一个函数来度量拟合的程度：$$ J(\theta)=\frac{1}{2m}\sum_{i=1}^m(h_\theta(x^i)-y^i)^2 $$上式中$h_\theta$表示利用拟合出来的直线计算出的第i个数据的预测结果，y表示实际结果，直观的表达式理解为每个房屋的预测值与实际值之差的平方和。目标：得出$h_\theta(x)$的表达式；怎么画出直线由参数$\theta$决定；为使得$\theta$取值使得结果尽量准确则需$minJ(\theta)$ 2.2 最小二乘解法-梯度下降(Gradient descent)对于梯度下降，Ng在课上给的比喻：想象你正站在一个山坡上，你环顾四周，找到一个坡度最陡的方向，往那个方向走一步，然后再往坡度最陡的方向走出相同长度的一步，当你用同样的方式走了很多步的时候，你最终会到达一个最低点。注意点： 走到的不一定是整座山的最低点，可能只是个山洼，即局部最小； 由于步长的取值，可能会在最低点附近徘徊，注意调整步长； 未完]]></content>
      <categories>
        <category>Meachine learning</category>
      </categories>
      <tags>
        <tag>Regression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[概率基础知识]]></title>
    <url>%2Fprobability%2F</url>
    <content type="text"><![CDATA[###一、概率基础]]></content>
      <categories>
        <category>Meachine learning</category>
      </categories>
      <tags>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSO 单点登录简单实现]]></title>
    <url>%2Fsso%2F</url>
    <content type="text"><![CDATA[1.知识点 单点登录: 简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统. Redis: 一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。 RedisHelper已发布在nuget 中，通过Install-Package WebFramework.Redis -Version 1.3.0安装引用.redis 界面工具: redis deskto调用方法如下： 123456789101112131415161. 配置config文件：&lt;connectionStrings&gt;//redis 服务器&lt;add name=&quot;RedisConnectionString&quot; connectionString=&quot;ipaddress:6379&quot; /&gt;&lt;/connectionStrings&gt;&lt;appSettings&gt;//key前缀 可以不设置&lt;add key=&quot;DefaultKey&quot; value=&quot;SSO_&quot; /&gt;&lt;/appSettings&gt;2. 实现：var redis = new RedisHelper(1);redis.StringSet(&quot;key&quot;, &quot;asda&quot;); //设置key-valuevar stringre = redis.StringGet(&quot;key&quot;);redis.HashSet(&quot;hashkey1&quot;, &quot;fild1&quot;, new UserInfo &#123; DisplayName = &quot;贴，&quot;, NetId = &quot;asd&quot;, DateTime = DateTime.Now &#125;);//hash 设置值var h1 = redis.HashSetAsync&lt;UserInfo&gt;(&quot;hashkey2&quot;, &quot;fild2&quot;, new UserInfo &#123; DisplayName = &quot;张，&quot;, NetId = &quot;asd&quot;, DateTime = DateTime.Now &#125;);//异步取值 2.原理12345678910111213141516171819202122231. 配置webconfig：&lt;!--服务端凭证过期时间(分钟)--&gt; &lt;add key=&quot;CacheTimeOut&quot; value=&quot;60&quot; /&gt; &lt;!--登录地址--&gt;&lt;add key=&quot;SSOurl&quot; value=&quot;http://localhost:49694&quot;/&gt;2. Push ，在子站点后添加web Reference: TicketService.asmx3. 目前在code behind 代码中，需要在授权页面使用如下代码实现单点登录Token.TicketService Ts = new Token.TicketService(); //无Token 验证 if (Request.QueryString[&quot;Token&quot;] == null) Response.Redirect(Ts.GetTokenUrl(Request.Url.AbsoluteUri)); if (Request.QueryString[&quot;Token&quot;] == &quot;$Token$&quot;) Response.Redirect(Ts.ReplaceUrl(Request.Url.AbsoluteUri)); string tokenValue = Request.QueryString[&quot;Token&quot;]; var userInfo = Ts.GetUserInfoByToken(tokenValue); if (userInfo != null) &#123; Session[&quot;UserInfo&quot;] = new UserInfo &#123; UserId = userInfo.NetId, UserName = userInfo.DisplayName, MailAddr = userInfo.MailAddress, mytasks = false, Token = tokenValue &#125;; &#125; else &#123; Response.Redirect(Ts.ReplaceUrl(Request.Url.AbsoluteUri)); &#125; 子站点（www.a.com）访问：（1） 无令牌，请求主站（account/default），通过User.Identity.IsAuthenticated 判断是否登录过（主站登录使用的是Form 表单登录）,若登录过，则返回令牌. 否则返回子站点。（2） 主站未登录过，重新请求主站登录页面（account/index）,登录成功后，生成令牌与对应的凭证，凭证信息中包含（本地cookie信息，用户信息），返回子站点并携带令牌。子站点通过令牌调用webservice 从redis服务器中获取用户数据（包含netid,displayname,mailaddress）（3） 用户登出，清除cache，代码如下：123456789101112if (Session[&quot;UserInfo&quot;] != null) &#123; var sis = false; Token.TicketService Ts = new Token.TicketService(); var userinfo = Session[&quot;UserInfo&quot;] as UserInfo; if (!string.IsNullOrEmpty(userinfo.Token)) &#123; sis = Ts.ClearToken(userinfo.Token); Session[&quot;UserInfo&quot;] = null; Response.Redirect(&quot;ReportView.aspx&quot;); &#125; &#125; 源代码之后上传到github.end.]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>SSO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 常用命令]]></title>
    <url>%2FGitFile%2F</url>
    <content type="text"><![CDATA[一. 理解 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 二. 新建Repository 创建本地仓库1234567git init #git 初始化 git add . #添加所有文件到暂存区git commit -m &quot;content&quot; #添加备注提交本地仓库git remote add origin http://url.git # 添加远程仓库路径git push -u origin master #push 代码到远程仓库git push remote [remote][branch] #上面两行代码的合并 2.复制远程仓库1git clone [url] 三. 配置123git config --list #显示所有Git配置git config --global user.name &quot;username&quot;git config --global user.email &quot;email address&quot; 四. 需要记住的123456789101112131415git add . git commit -m &quot;content&quot;git branch #列出所有本地分支git branch -r #列出所有远程分支git branch -a #列出所有本地和远程分支git branch [分支名字] #新建分支git checkout [分支名字] #切换到指定分支git merge [分支名字] #合并指定分支到当前分支git status #显示有变更的文件git log #显示当前分支的版本历史git diff #显示暂存区和工作区的代码差异git checkout [file] #恢复暂存区的指定文件到工作区git checkout . #恢复暂存区的所有文件到工作区git reset --hard [commit] #让工作区回到上次commit的状态,同时重置暂存区和工作区，回滚到某个版本，该版本之后的所有代码丢失，慎用！git revert #未完]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FormAuth表单验证]]></title>
    <url>%2FFormAuth%2F</url>
    <content type="text"><![CDATA[表单验证整理1234567891011121314151617181920212223242526272829303132333435363738394041#region Form 表单验证 //第一种方法 第一个参数对应第二种方法 票据中的第二个参数 //FormsAuthentication.SetAuthCookie(UserInfo.NetId, true); //第二种方法 可以多存放一个UserData （一般可以用来存放Role信息） //1. 生成Ticket FormsAuthenticationTicket Ticket = new FormsAuthenticationTicket(1, //VersionUserInfo.NetId, //用户关键信息DateTime.Now, //Cookie发起时间 DateTime.Now.AddHours(2), //Cookie有效期true, //Cookie是否持久UserInfo.DisplayName // USERDATA 可以自定义); //2.生成Cookie FormsAuthentication.Encrypt(Ticket) 对Ticket加密, FormsAuthentication.FormsCookieName ==Webconfig中name=.ASPXAUTH HttpCookie Cookie = new HttpCookie(FormsAuthentication.FormsCookieName, FormsAuthentication.Encrypt(Ticket)); //3.设置Cookie有效期 Cookie.Expires = DateTime.Now.AddHours(2); //4.将身份验证票Cookie附加到输出的cookie集合中,发送到客户端. Response.Cookies.Add(Cookie); #endregion #region Webconfig 配置 &lt;system.web&gt;中 //&lt;authentication mode=&quot;Forms&quot;&gt; // &lt;forms name=&quot;.ASPXAUTH&quot; loginUrl=&quot;~/Account/Login&quot; protection=&quot;All&quot; path=&quot;/&quot; timeout=&quot;2880&quot; /&gt; //&lt;/authentication&gt; //&lt;authorization&gt; // &lt;allow users=&quot;*&quot; /&gt; //&lt;/authorization&gt; #endregion#region 退出 FormsAuthentication.SignOut(); Redirect(FormsAuthentication.LoginUrl);#endregion#region 使用1. HttpContext.Request.User.Identity.IsAuthenticated Ture/False 是否验证通过授权验证2. HttpContext.Request.User.Identity.Name 获取Tickct 中用户信息 UserName#endregion]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>ASP.NET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitblit环境]]></title>
    <url>%2FGitBit%2F</url>
    <content type="text"><![CDATA[Gitblit服务器环境搭配自己搭建一个GIT服务器，存放代码，准备如下： *服务器一台（先用的自己的） *配置java环境，下载地址[http://www.java.com/zh_CN/] *下载gitblit 地址：[http://www.gitblit.com/] java环境配置下载软件之后，一步步双击，完成后打开cmd界面，输入java回车，如下图，表示安装成。并没有去配置环境变量，已经自动配置 GitBlit配置下载之后创建一个文件夹存放GitBlit解压包，另一个为GitRepository 源代码 1.配置文件修改：data-&gt;gitblit.properties -&gt;include = defaults.properties 如果需要配置新的配置文件，可更换，否则不改动也可以 2.同级目录下找到defaults.properties 文件，打开之后，修改以下内容： *git.repositoriesFolder = C:/Person/Git/GitRepository（资料库及代码存放位置） *server.httpPort = 80 设置端口号 *server.storePassword = 123456 设置超级密码 *server.httpBindInterface =172.16.0.246 *server.httpsBindInterface =172.16.0.246 *server.certificateAlias = 172.16.0.246 先设置为自己的ip地址，局域网内可访问 3.保存后，返回上级目录，执行gitblit.cmd批处理命令，成功提示如下图，即可访问172.16.0.246 4.Gitblit设置以windows service 方式启动 *在根目录下找到installService.cmd，以记事本打开,添加SET CD = C:\Person\Git\GitBit *设置StartParams=“” 修改完成如下图： 至此，配置完成.]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
